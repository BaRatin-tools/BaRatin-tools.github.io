---
title: "Using RBaM"
subtitle: "BaRatin in R!"
slug: "rbam"
weight: 5
layout: "doc_caseStudiesPage"
inTOC: "caseStudies"    
output:
  blogdown::html_page:
    number_sections: true
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE,results='hide',
                      fig.path = "en/fig-")
```

# Introduction

BaM (Bayesian Modeling) is a framework to estimate a model using Bayesian inference - any model in general, but BaRatin's rating curve in particular. The R package [RBaM](https://github.com/BaM-tools/RBaM) is built as an R User Interface to [BaM's computational engine](https://github.com/BaM-tools/BaM). It defines classes (objects' properties and methods) for the various building blocks of a BaM case study. Its typical usage is as follows:

1. Assemble the dataset of input/ouput variables.
2. Define the model and set prior distributions for its parameters.
3. Perform Bayesian-MCMC inference.
4. Perform predictions.

`RBaM` needs to be installed once then loaded at every use.

```{r message=FALSE}
# devtools::install_github('BaM-tools/RBaM') # First use: install the package from GitHub
library(RBaM) # Load package
```

The catalog of distributions that can be used for prior specification can be accessed as shown below. The command also gives the list of available models, but here we'll solely focus on BaRatin.

```{r results='markup'}
getCatalogue()
```

# Estimation of a BaRatin rating curve

The first thing to do is to define the workspace, i.e. the folder where all result files will be written.

```{r}
workspace=file.path(getwd(),'BaM_workspace')
```

The example used below is based on the rating curve for the [Ardèche river](https://en.wikipedia.org/wiki/Ardèche_(river)) at the [Sauze-Saint-Martin](https://www.hydro.eaufrance.fr/stationhydro/V506401001/fiche) hydrometric station. 

## Defining streamgauging data

The streamgauging dataset used to calibrate the rating curve is provided with the `RBaM` package. This dataset is named `SauzeGaugings` and the code below is used to let RBaM know what variable to use as inputs/outputs of the model. Since the model here is a rating curve, stage is the input and streamflow the output. 

```{r}
# Define the calibration dataset by specifying 
# inputs (X), outputs (Y) and uncertainty on the outputs (Yu).
# A copy of this dataset will be written in data.dir.
D=dataset(X=SauzeGaugings['H'],Y=SauzeGaugings['Q'],Yu=SauzeGaugings['uQ'],data.dir=workspace)
```

## Defining the rating curve model

This station is characterized by a simple 2-control hydraulic configuration, with a natural riffle acting as the low-flow section control, and a wide rectangular channel acting as the high-flow control, as illustrated below. 

<br>
<img src="Sauze.jpg" width="70%">
<p style="text-align: center;color: gray;"> Hydraulic configuration for the Ardèche River at Sauze-Saint-Martin station (staff gauge is shown in yellow). (a) properties of the high-flow controlling chanel; (b) zoom on the low-flow controlling section.</p>


The code below specifies the priors on parameters, the control matrix and creates the model object.

```{r}
# Parameters of the low flow section control: activation stage k, coefficient a and exponent c
k1=parameter(name='k1',init=-0.5,prior.dist='Uniform',prior.par=c(-1.5,0))
a1=parameter(name='a1',init=30,prior.dist='LogNormal',prior.par=c(log(30),1))
c1=parameter(name='c1',init=1.5,prior.dist='Gaussian',prior.par=c(1.5,0.05))
# Parameters of the high flow channel control: activation stage k, coefficient a and exponent c
k2=parameter(name='k2',init=1,prior.dist='Gaussian',prior.par=c(1,1))
a2=parameter(name='a2',init=100,prior.dist='LogNormal',prior.par=c(log(100),1))
c2=parameter(name='c2',init=1.67,prior.dist='Gaussian',prior.par=c(1.67,0.05))
# Define control matrix: columns are controls, rows are stage ranges.
# Here the matrix means that the first control only is active for the first stage range,
# and the second control only is active for the second stage range.
controlMatrix=rbind(c(1,0),c(0,1))
# Stitch it all together into a model object
M=model(ID='BaRatin',
        nX=1,nY=1, # number of input/output variables: here 1 input (H) and 1 output (Q)
        par=list(k1,a1,c1,k2,a2,c2), # list of model parameters
        xtra=xtraModelInfo(object=controlMatrix)) # use xtraModelInfo() to pass the control matrix
```

## Running BaM and exploring MCMC samples

All set! The function BaM can now be called to estimate parameters. This will run a MCMC sampler and save the result into the workspace.

```{r results='markup'}
BaM(mod=M,data=D) # Estimate the parameters of model M using calibration data D
```

MCMC samples can now be read. There are 2 MCMC files: 'Results_MCMC.txt' contains raw MCMC simulations and is hence quite big. 'Results_Cooking.txt' contains 'cooked' simulations, i.e. after 'burning' the first part of iterations and 'slicing' what remains, and may be favored in most cases. Functions `mcmcOptions()` and `mcmcCooking()` allow controlling MCMC properties.

```{r results='markup'}
# Read 'cooked' MCMC file in the workspace
MCMC=readMCMC(file.path(workspace,'Results_Cooking.txt'))
head(MCMC)
```

A few functions are provided with the package to explore MCMC samples.

```{r fig.height=6, fig.width=9}
# Trace plot for each parameter, useful to assess convergence.
plots=tracePlot(MCMC)
gridExtra::grid.arrange(grobs=plots,ncol=3)
```

```{r fig.height=6, fig.width=9, warning=FALSE}
# Density plot for each parameter
plots=densityPlot(MCMC)
gridExtra::grid.arrange(grobs=plots,ncol=3)
```


```{r fig.height=3, fig.width=6}
# Violon plot, useful to compare 'comparable' parameters.
violinPlot(MCMC[c('c1','c2')])
```

## Estimating the rating curve and its uncertainty

Finally, the estimated rating curve model can be used to make predictions as shown below.

```{r}
# Define the grid of stage values on which the rating curve will be computed
hgrid=data.frame(H=seq(-1,7,0.1))
# Define a 'prediction' object for total predictive uncertainty
totalU=prediction(X=hgrid, # stage values
                  spagFiles='totalU.spag', # file where predictions are saved
                  data.dir=workspace, # a copy of data files will be saved here
                  doParametric=TRUE, # propagate parametric uncertainty, i.e. MCMC samples?
                  doStructural=TRUE) # propagate structural uncertainty ?
# Define a 'prediction' object for parametric uncertainty only - not the doStructural=FALSE
paramU=prediction(X=hgrid,spagFiles='paramU.spag',data.dir=workspace,
                  doParametric=TRUE,doStructural=FALSE)
# Define a 'prediction' object with no uncertainty - this corresponds to the 'maxpost' rating curve maximizing the posterior
maxpost=prediction(X=hgrid,spagFiles='maxpost.spag',data.dir=workspace,
                  doParametric=FALSE,doStructural=FALSE)
# Re-run BaM, but in prediction mode
BaM(mod=M,data=D, # model and data
    pred=list(totalU,paramU,maxpost), # list of predictions
    doCalib=FALSE,doPred=TRUE) # Do not re-calibrate but do predictions
```

The resulting 'spaghetti files' can be read into the workspace and plotted. 

```{r fig.height=6, fig.width=9}
# Plot spaghetti representing total uncertainty in red
Q=read.table(file.path(workspace,'totalU.spag'))
matplot(hgrid$H,Q,col='red',type='l',lty=1)
# Add spaghetti representing parametric uncertainty in pink
Q=read.table(file.path(workspace,'paramU.spag'))
matplot(hgrid$H,Q,col='pink',type='l',lty=1,add=TRUE)
# Add maxpost rating curve
Q=read.table(file.path(workspace,'maxpost.spag'))
matplot(hgrid$H,Q,col='black',type='l',lty=1,add=TRUE)
```

Spaghetti are the raw outputs of the predictions, but it is often more convenient to plot probability intervals only. These have been computed automatically by BaM, and are saved in files with an '.env' (like 'envelop') extension.

```{r fig.height=6, fig.width=9}
Q=read.table(file.path(workspace,'totalU.env'),header=T)
matplot(hgrid$H,Q[,2:3],col='red',type='l',lty=1)
Q=read.table(file.path(workspace,'paramU.env'),header=T)
matplot(hgrid$H,Q[,2:3],col='pink',type='l',lty=1,add=TRUE)
Q=read.table(file.path(workspace,'maxpost.spag'))
matplot(hgrid$H,Q,col='black',type='l',lty=1,add=TRUE)
```
